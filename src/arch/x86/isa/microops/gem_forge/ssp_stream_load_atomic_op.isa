
//////////////////////////////////////////////////////////////////////////
//
// Micro ops that uses one register and one immediate.
//
//////////////////////////////////////////////////////////////////////////

def template MicroSSPLoadAtomicOpExecute {{
        Fault %(class_name)s::execute(ExecContext *xc,
                trace::InstRecord *traceData) const
        {
            %(op_decl)s;
            %(op_rd)s;
            %(code)s;
            %(op_wb)s;
            return NoFault;
        }

        Fault
        %(class_name)s::initiateAcc(
            ExecContext *xc, trace::InstRecord *traceData) const {
            Fault fault = NoFault;
            return fault;
        }

        Fault
        %(class_name)s::completeAcc(
            PacketPtr pkt, ExecContext *xc, trace::InstRecord *traceData) const {
            Fault fault = NoFault;
            return fault;
        }
}};

def template MicroSSPLoadAtomicOpDeclare {{
    class %(class_name)s : public X86ISA::GemForgeMicroopBase
    {
      protected:
        const RegIndex dest;
        const uint64_t imm;
        const uint8_t dataSize;
        RegIndex foldOBit;

        std::string generateDisassembly(Addr pc,
            const gem5::loader::SymbolTable *symtab) const;

      public:
        %(class_name)s(ExtMachInst _machInst,
                const char * instMnem,
                uint64_t setFlags, RegIndex _dest,
                uint64_t _imm, uint8_t _dataSize);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(
            PacketPtr, ExecContext *, trace::InstRecord *) const override;
    };
}};

def template MicroSSPLoadAtomicOpDisassembly {{
    std::string %(class_name)s::generateDisassembly(Addr pc,
            const gem5::loader::SymbolTable *symtab) const
    {
        std::stringstream response;

        printMnemonic(response, instMnem, mnemonic);
        printReg(response, this->destRegIdx(0), dataSize);
        response << ", ";
        ccprintf(response, "%#x", imm);
        return response.str();
    }
}};

def template MicroSSPLoadAtomicOpConstructor {{
    %(class_name)s::%(class_name)s(
            ExtMachInst machInst, const char * instMnem, uint64_t setFlags,
            RegIndex _dest, uint64_t _imm, uint8_t _dataSize) :
        %(base_class)s(machInst, "%(mnemonic)s", instMnem,
                setFlags, %(op_class)s),
                dest(_dest), imm(_imm), dataSize(_dataSize)
    {
        foldOBit = (dataSize == 1 && !machInst.rex.present) ? 1 << 6 : 0;
        %(constructor)s;

        /**
         * ! GemForge
         * Explicitly mark the dest register.
         */
        %(user_constructor)s;
    }
}};

let {{
    class SSPStreamLoadAtomicOp(X86Microop):
        op_class = "MemReadOp"
        def __init__(self, dest, imm, dataSize="env.dataSize", isFloat=False, isAtomic=False):
            if isFloat and isAtomic:
                self.className = "SSPStreamFAtomic"
            elif isFloat:
                self.className = "SSPStreamFLoad"
            elif isAtomic:
                self.className = "SSPStreamAtomic"
            else:
                self.className = "SSPStreamLoad"
            # ! Gem Forge
            # ! Get rid of the type and just use the index.
            self.dest = "((%s).index)" % dest
            if isinstance(imm, int):
                imm = "ULL(%d)" % imm
            self.imm = imm
            self.dataSize = dataSize

        def getAllocator(self, microFlags):
            allocString = '''
                (StaticInstPtr)(new %(class_name)s(machInst,
                    macrocodeBlock, %(flags)s, %(dest)s, %(imm)s,
                    %(dataSize)s))
            '''
            allocator = allocString % {
                "class_name" : self.className,
                "flags" : self.microFlagsText(microFlags),
                "dest" : self.dest,
                "imm" : self.imm,
                "dataSize" : self.dataSize
            }
            return allocator

    microopClasses["ssp_stream_load"] = SSPStreamLoadAtomicOp
    microopClasses["ssp_stream_fload"] = SSPStreamLoadAtomicOp
    microopClasses["ssp_stream_atomic"] = SSPStreamLoadAtomicOp
    microopClasses["ssp_stream_fatomic"] = SSPStreamLoadAtomicOp
}};

let {{
    iops = [
        InstObjParams(
            "ssp_stream_load", # mnemonic
            "SSPStreamLoad", # class name
            'GemForgeMicroopBase',
            {
                'code' : '',
                'user_constructor': """
                    flags[IsInteger] = true;
                    destRegIdxArr[_numDestRegs++] = intRegClass[dest];
                    _numTypedDestRegs[intRegClass.type()]++;
                """,
            },
            ['MemReadOp', 'IsLoad', 'IsGemForge']
        ),
        InstObjParams(
            "ssp_stream_fload",
            "SSPStreamFLoad",
            'GemForgeMicroopBase',
            {
                'code' : '',
                'user_constructor': """
                    flags[IsFloating] = true;
                    /**
                     * ! GemForge
                     * Hack to also mark higher bits as my destination.
                     * Make sure we correctly handle case when dataSize < 64.
                     */
                    for (int i = 0; i < (dataSize + sizeof(uint64_t) - 1) / sizeof(uint64_t); i++) {
                        assert(_numDestRegs < MaxInstDestRegs && "DestRegs overflow.");
                        destRegIdxArr[_numDestRegs++] = floatRegClass[dest + i];
                        _numTypedDestRegs[floatRegClass.type()]++;
                    }
                """,
            },
            ['FloatMemReadOp', 'IsLoad', 'IsGemForge']
        ),
        InstObjParams(
            "ssp_stream_atomic",
            "SSPStreamAtomic",
            'GemForgeMicroopBase',
            {
                'code' : '',
                'user_constructor': """
                    flags[IsInteger] = true;
                    destRegIdxArr[_numDestRegs++] = intRegClass[dest];
                    _numTypedDestRegs[intRegClass.type()]++;
                """,
            },
            ['MemReadOp', 'IsAtomic', 'IsGemForge']
        ),
        InstObjParams(
            "ssp_stream_fatomic",
            "SSPStreamFAtomic",
            'GemForgeMicroopBase',
            {
                'code' : '',
                'user_constructor': """
                    flags[IsFloating] = true;
                    /**
                     * ! GemForge
                     * Hack to also mark higher bits as my destination.
                     * Make sure we correctly handle case when dataSize < 64.
                     */
                    for (int i = 0; i < (dataSize + sizeof(uint64_t) - 1) / sizeof(uint64_t); i++) {
                        assert(_numDestRegs < MaxInstDestRegs && "DestRegs overflow.");
                        destRegIdxArr[_numDestRegs++] = floatRegClass[dest + i];
                        _numTypedDestRegs[floatRegClass.type()]++;
                    }
                """,
            },
            ['FloatMemReadOp', 'IsAtomic', 'IsGemForge']
        ),
    ]
    for iop in iops:
        header_output += MicroSSPLoadAtomicOpDeclare.subst(iop)
        decoder_output += MicroSSPLoadAtomicOpConstructor.subst(iop)
        decoder_output += MicroSSPLoadAtomicOpDisassembly.subst(iop)
        exec_output += MicroSSPLoadAtomicOpExecute.subst(iop)
}};
