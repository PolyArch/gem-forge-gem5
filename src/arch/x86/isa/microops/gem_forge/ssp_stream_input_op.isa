
//////////////////////////////////////////////////////////////////////////
//
// Micro ops that uses one source register and one immediate.
//
//////////////////////////////////////////////////////////////////////////

def template MicroSSPInputOpExecute {{
        Fault %(class_name)s::execute(ExecContext *xc,
                trace::InstRecord *traceData) const
        {
            %(op_decl)s;
            %(op_rd)s;
            %(code)s;
            %(op_wb)s;
            return NoFault;
        }
}};

def template MicroSSPInputOpDeclare {{
    class %(class_name)s : public X86ISA::GemForgeMicroopBase
    {
      protected:
        const RegIndex src1;
        const uint64_t imm;
        const uint8_t dataSize;
        RegIndex foldOBit;

        std::string generateDisassembly(Addr pc,
            const gem5::loader::SymbolTable *symtab) const;

      public:
        %(class_name)s(ExtMachInst _machInst,
                const char * instMnem,
                uint64_t setFlags, RegIndex _src1,
                uint64_t _imm, uint8_t _dataSize);

        Fault execute(ExecContext *, trace::InstRecord *) const;
    };
}};

def template MicroSSPInputOpDisassembly {{
    std::string %(class_name)s::generateDisassembly(Addr pc,
            const gem5::loader::SymbolTable *symtab) const
    {
        std::stringstream response;

        printMnemonic(response, instMnem, mnemonic);
        printReg(response, this->srcRegIdx(0), dataSize);
        response << ", ";
        ccprintf(response, "%#x", imm);
        return response.str();
    }
}};

def template MicroSSPInputOpConstructor {{
    %(class_name)s::%(class_name)s(
            ExtMachInst machInst, const char * instMnem, uint64_t setFlags,
            RegIndex _src1, uint64_t _imm, uint8_t _dataSize) :
        %(base_class)s(machInst, "%(mnemonic)s", instMnem,
                setFlags, %(op_class)s),
                src1(_src1), imm(_imm), dataSize(_dataSize)
    {
        foldOBit = (dataSize == 1 && !machInst.rex.present) ? 1 << 6 : 0;
        %(constructor)s;
        // Manually mark all the source register.
        switch(dataSize) {
        case 4:
        case 8:
                srcRegIdxArr[_numSrcRegs++] = intRegClass[src1];
            break;
        case 16:
            // xmm
                srcRegIdxArr[_numSrcRegs++] = floatRegClass[src1 + 0] ;
                srcRegIdxArr[_numSrcRegs++] = floatRegClass[src1 + 1] ;
            break;
        case 32:
            // zmm
                srcRegIdxArr[_numSrcRegs++] = floatRegClass[src1 + 0] ;
                srcRegIdxArr[_numSrcRegs++] = floatRegClass[src1 + 1] ;
                srcRegIdxArr[_numSrcRegs++] = floatRegClass[src1 + 2] ;
                srcRegIdxArr[_numSrcRegs++] = floatRegClass[src1 + 3] ;
            break;
        case 64:
            // zmm
                srcRegIdxArr[_numSrcRegs++] = floatRegClass[src1 + 0] ;
                srcRegIdxArr[_numSrcRegs++] = floatRegClass[src1 + 1] ;
                srcRegIdxArr[_numSrcRegs++] = floatRegClass[src1 + 2] ;
                srcRegIdxArr[_numSrcRegs++] = floatRegClass[src1 + 3] ;
                srcRegIdxArr[_numSrcRegs++] = floatRegClass[src1 + 4] ;
                srcRegIdxArr[_numSrcRegs++] = floatRegClass[src1 + 5] ;
                srcRegIdxArr[_numSrcRegs++] = floatRegClass[src1 + 6] ;
                srcRegIdxArr[_numSrcRegs++] = floatRegClass[src1 + 7] ;
            break;
        default:
            panic("Unsupported dataSize %d for SSPStreamInput.\n", dataSize);
            break;
        }
    }
}};

let {{
    class SSPStreamInputOp(X86Microop):
        op_class = "No_OpClass"
        def __init__(self, src, imm, dataSize="env.dataSize"):
            self.className = "SSPStreamInput"
            self.mnemonic = "ssp.stream.input"
            # ! GemForge
            # Get rid of the type and just use the index
            self.src = "((%s).index)" % src
            if isinstance(imm, int):
                imm = "ULL(%d)" % imm
            self.imm = imm
            self.dataSize = dataSize

        def getAllocator(self, microFlags):
            allocString = '''
                (StaticInstPtr)(new %(class_name)s(machInst,
                    macrocodeBlock, %(flags)s, %(src)s, %(imm)s,
                    %(dataSize)s))
            '''
            allocator = allocString % {
                "class_name" : self.className,
                "mnemonic" : self.mnemonic,
                "flags" : self.microFlagsText(microFlags),
                "src" : self.src,
                "imm" : self.imm,
                "dataSize" : self.dataSize
            }
            return allocator

    microopClasses["ssp_stream_input"] = SSPStreamInputOp

    class SSPStreamStepAmntOp(X86Microop):
        op_class = "No_OpClass"
        def __init__(self, src, imm, dataSize="env.dataSize"):
            self.className = "SSPStreamStepAmnt"
            self.mnemonic = "ssp.stream.step_amnt"
            # ! GemForge
            # Get rid of the type and just use the index
            self.src = "((%s).index)" % src
            if isinstance(imm, int):
                imm = "ULL(%d)" % imm
            self.imm = imm
            self.dataSize = dataSize

        def getAllocator(self, microFlags):
            allocString = '''
                (StaticInstPtr)(new %(class_name)s(machInst,
                    macrocodeBlock, %(flags)s, %(src)s, %(imm)s,
                    %(dataSize)s))
            '''
            allocator = allocString % {
                "class_name" : self.className,
                "mnemonic" : self.mnemonic,
                "flags" : self.microFlagsText(microFlags),
                "src" : self.src,
                "imm" : self.imm,
                "dataSize" : self.dataSize
            }
            return allocator

    microopClasses["ssp_stream_step_amnt"] = SSPStreamStepAmntOp
}};

let {{
    iops = [
        InstObjParams(
            "ssp_stream_input",
            "SSPStreamInput",
            'GemForgeMicroopBase',
            {
                'code' : '',
            },
            ['No_OpClass', 'IsGemForge']
        ),
        InstObjParams(
            "ssp_stream_step_amnt",
            "SSPStreamStepAmnt",
            'GemForgeMicroopBase',
            {
                'code' : '',
            },
            ['No_OpClass', 'IsGemForge']
        ),
    ]
    for iop in iops:
        header_output += MicroSSPInputOpDeclare.subst(iop)
        decoder_output += MicroSSPInputOpConstructor.subst(iop)
        decoder_output += MicroSSPInputOpDisassembly.subst(iop)
        exec_output += MicroSSPInputOpExecute.subst(iop)
}};
