
//////////////////////////////////////////////////////////
//
// GemForgeInsts should provide more hooks.
//

def template GemForgeDeclare {{
    //
    // Static instruction class for "%(mnemonic)s".
    //
    class %(class_name)s : public %(base_class)s {
      public:
        /// Constructor.
        %(class_name)s(MachInst machInst);
        Fault execute(
            ExecContext *xc,
            Trace::InstRecord *traceData) const override;
        std::string generateDisassembly(
            Addr pc,
            const SymbolTable *symtab) const override;
        /// More hooks.
        bool canDispatch(
            ExecContext *xc,
            Trace::InstRecord *traceData) const override;
        Fault dispatch(
            ExecContext *xc,
            Trace::InstRecord *traceData) const override;
        Fault commit(
            ExecContext *xc,
            Trace::InstRecord *traceData) const override;
    };
}};

def template GemForgeExecute {{

    bool
    %(class_name)s::canDispatch(
        ExecContext *xc, Trace::InstRecord *traceData) const {
        Fault fault = NoFault;

        %(op_decl)s;
        %(op_rd)s;
        if (fault == NoFault) {
            %(can_dispatch_code)s;
        }

        return false;
    }

    Fault
    %(class_name)s::dispatch(
        ExecContext *xc, Trace::InstRecord *traceData) const {
        Fault fault = NoFault;

        if (fault == NoFault) {
            %(dispatch_code)s;
            return fault;
        }

        return fault;
    }

    Fault
    %(class_name)s::execute(
        ExecContext *xc, Trace::InstRecord *traceData) const {
        Fault fault = NoFault;

        %(op_decl)s;
        %(op_rd)s;
        if (fault == NoFault) {
            %(execute_code)s;
            if (fault == NoFault) {
                %(op_wb)s;
            }
        }

        return fault;
    }

    Fault
    %(class_name)s::commit(
        ExecContext *xc, Trace::InstRecord *traceData) const {
        Fault fault = NoFault;

        if (fault == NoFault) {
            %(commit_code)s;
            return fault;
        }

        return fault;
    }

    std::string
    %(class_name)s::generateDisassembly(Addr pc,
            const SymbolTable *symtab) const {
        std::vector<RegId> indices = {%(regs)s};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }
}};

def format GemForgeIOp(
        can_dispatch_code,
        dispatch_code,
        execute_code,
        commit_code,
        imm_type='int64_t', *opt_flags) {{
    regs = ['_destRegIdx[0]','_srcRegIdx[0]']
    iop = InstObjParams(
        # parse
        name,
        # mnem
        Name,
        # base_class
        'ImmOp<%s>' % imm_type,
        # snippets
        {
            'can_dispatch_code': can_dispatch_code,
            'dispatch_code': dispatch_code,
            'execute_code': execute_code,
            'commit_code': commit_code,
            'imm_code': 'imm = sext<12>(IMM12);',
            'regs': ','.join(regs)
        },
        opt_flags,
    )
    header_output = GemForgeDeclare.subst(iop)
    decoder_output = ImmConstructor.subst(iop)
    decode_block = BasicDecode.subst(iop)
    exec_output = GemForgeExecute.subst(iop)
}};
