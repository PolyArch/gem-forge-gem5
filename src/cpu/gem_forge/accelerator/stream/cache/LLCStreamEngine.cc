
#include "LLCStreamEngine.hh"

#include "mem/ruby/slicc_interface/AbstractStreamAwareController.hh"

// Generated by slicc.
#include "mem/protocol/StreamMigrateRequestMsg.hh"

#include "cpu/gem_forge/llvm_trace_cpu.hh"

#include "base/trace.hh"
#include "debug/RubyStream.hh"

#define LLCSE_DPRINTF(format, args...)                                         \
  DPRINTF(RubyStream, "[LLC_SE%d]: " format,                                   \
          this->controller->getMachineID().num, ##args)

#define LLC_STREAM_DPRINTF(streamId, format, args...)                          \
  DPRINTF(RubyStream, "[LLC_SE%d][%lu]: " format,                              \
          this->controller->getMachineID().num, streamId, ##args)

#define LLC_ELEMENT_DPRINTF(streamId, startIdx, numElements, format, args...)  \
  DPRINTF(RubyStream, "[LLC_SE%d][%lu][%lu, +%d): " format,                    \
          this->controller->getMachineID().num, streamId, startIdx,            \
          numElements, ##args)

LLCStreamEngine::LLCStreamEngine(AbstractStreamAwareController *_controller,
                                 MessageBuffer *_streamMigrateMsgBuffer,
                                 MessageBuffer *_streamIssueMsgBuffer,
                                 MessageBuffer *_streamIndirectIssueMsgBuffer)
    : Consumer(_controller), controller(_controller),
      streamMigrateMsgBuffer(_streamMigrateMsgBuffer),
      streamIssueMsgBuffer(_streamIssueMsgBuffer),
      streamIndirectIssueMsgBuffer(_streamIndirectIssueMsgBuffer),
      issueWidth(1), migrateWidth(1) {}

LLCStreamEngine::~LLCStreamEngine() {
  for (auto &s : this->streams) {
    delete s;
    s = nullptr;
  }
  this->streams.clear();
}

void LLCStreamEngine::receiveStreamConfigure(PacketPtr pkt) {
  auto streamConfigureData = *(pkt->getPtr<CacheStreamConfigureData *>());
  LLCSE_DPRINTF("Received Pkt %#x, StreamConfigure %#x, initVAddr "
                "%#x, "
                "initPAddr %#x.\n",
                pkt, streamConfigureData, streamConfigureData->initVAddr,
                streamConfigureData->initPAddr);
  // Create the stream.
  auto stream = new LLCDynamicStream(streamConfigureData);

  // Check if we have indirect streams.
  if (streamConfigureData->indirectStream != nullptr) {
    // Let's create an indirect stream.
    // Fake a configure data to make the constructor happy.
    CacheStreamConfigureData indirectStreamConfigureData(
        streamConfigureData->indirectStream,
        streamConfigureData->indirectDynamicId,
        streamConfigureData->indirectHistory);
    indirectStreamConfigureData.initAllocatedIdx =
        streamConfigureData->initAllocatedIdx;
    auto indirectStream = new LLCDynamicStream(&indirectStreamConfigureData);
    stream->indirectStreams.push_back(indirectStream);
  }

  this->streams.emplace_back(stream);
  // Release memory.
  delete streamConfigureData;
  delete pkt;

  // Let's schedule a wakeup event.
  this->scheduleEvent(Cycles(1));
}

void LLCStreamEngine::receiveStreamMigrate(LLCDynamicStreamPtr stream) {

  Addr vaddr = stream->peekVAddr();
  Addr paddr = stream->translateToPAddr(vaddr);
  Addr paddrLine = makeLineAddress(paddr);
  assert(this->isPAddrHandledByMe(paddrLine) &&
         "Stream migrated to wrong LLC bank.\n");
  LLC_STREAM_DPRINTF(stream->getStaticId(), "Received migrate.\n");

  this->streams.push_back(stream);
  this->scheduleEvent(Cycles(1));
}

void LLCStreamEngine::receiveStreamFlow(const StreamMeta &streamMeta) {
  // Simply append it to the list.
  LLCSE_DPRINTF("Received stream flow [%lu, %lu).\n", streamMeta.m_startIdx,
                streamMeta.m_startIdx + streamMeta.m_numElements);
  this->pendingStreamFlowControlMsgs.push_back(streamMeta);
  this->scheduleEvent(Cycles(1));
}

void LLCStreamEngine::receiveStreamElementData(const StreamMeta &streamMeta) {
  // First find the stream.
  assert(streamMeta.m_fwdToSE &&
         "This stream element data should not be forward here.");
  LLCDynamicStream *stream = nullptr;
  for (auto S : this->streams) {
    if (S->configData.dynamicId == streamMeta.m_streamId) {
      stream = S;
      break;
    }
  }
  assert(stream != nullptr && "Failed to find the base stream.");
  LLC_ELEMENT_DPRINTF(stream->getStaticId(), streamMeta.m_startIdx,
                      streamMeta.m_numElements, "Received element data.\n");
  for (auto idx = streamMeta.m_startIdx,
            endIdx = streamMeta.m_startIdx + streamMeta.m_numElements;
       idx < endIdx; ++idx) {
    assert(stream->waitingIndirectElements.count(idx) == 1 &&
           "There is no waiting indirect element for this index.");
    // Add them to the ready indirect list.
    for (auto indirectStream : stream->indirectStreams) {
      stream->readyIndirectElements.emplace(idx, indirectStream);
    }
    // Don't forget to erase it from the waiting list.
    stream->waitingIndirectElements.erase(idx);
  }
}

bool LLCStreamEngine::canMigrateStream(LLCDynamicStream *stream) const {
  auto nextVAddr = stream->peekVAddr();
  auto nextPAddr = stream->translateToPAddr(nextVAddr);
  // Check if it is still on this bank.
  bool shouldMigrate = !this->isPAddrHandledByMe(nextPAddr);
  // Also check that there is no unissued indirect elements.
  return shouldMigrate && stream->waitingIndirectElements.empty() &&
         stream->readyIndirectElements.empty();
}

void LLCStreamEngine::wakeup() {
  this->processStreamFlowControlMsg();
  this->issueStreams();
  this->migrateStreams();
  if (!this->streams.empty() || !this->migratingStreams.empty()) {
    this->scheduleEvent(Cycles(1));
  }
}

void LLCStreamEngine::processStreamFlowControlMsg() {
  auto iter = this->pendingStreamFlowControlMsgs.begin();
  auto end = this->pendingStreamFlowControlMsgs.end();
  while (iter != end) {
    const auto &msg = *iter;
    auto staticStream = reinterpret_cast<Stream *>(msg.m_stream);
    // So far we just use the static stream id (pointer),
    // TODO: We may need a dynamic id to distinguish different dynamic
    // TODO: instances.
    bool processed = false;
    for (auto stream : this->streams) {
      if (stream->getStaticStream() == staticStream &&
          msg.m_startIdx == stream->allocatedIdx) {
        // We found it.
        // Update the idx.
        LLC_STREAM_DPRINTF(stream->getStaticId(), "Add credit %lu -> %lu.\n",
                           msg.m_startIdx, msg.m_startIdx + msg.m_numElements);
        stream->addCredit(msg.m_numElements);
        processed = true;
        break;
      }
    }
    if (processed) {
      iter = this->pendingStreamFlowControlMsgs.erase(iter);
    } else {
      LLCSE_DPRINTF("Failed to process stream credit %#x [%lu, %lu).\n",
                    msg.m_stream, msg.m_startIdx,
                    msg.m_startIdx + msg.m_numElements);
      ++iter;
    }
  }
}

void LLCStreamEngine::issueStreams() {
  auto streamIter = this->streams.begin();
  auto streamEnd = this->streams.end();
  StreamList issuedStreams;
  while (streamIter != streamEnd && issuedStreams.size() < this->issueWidth) {
    auto stream = *streamIter;
    bool issued = this->issueStream(stream);
    if (issued) {
      // Check if we want to migrate the stream.
      issuedStreams.emplace_back(stream);
      streamIter = this->streams.erase(streamIter);
    } else {
      // Move to the next one.
      ++streamIter;
    }
  }

  for (auto stream : issuedStreams) {
    bool shouldMigrate = this->canMigrateStream(stream);
    if (shouldMigrate) {
      this->migratingStreams.emplace_back(stream);
    } else {
      this->streams.emplace_back(stream);
    }
  }
}

bool LLCStreamEngine::issueStream(LLCDynamicStream *stream) {

  /**
   * Prioritize indirect elements.
   */
  if (this->issueStreamIndirect(stream)) {
    // We successfully issued an indirect element of this stream.
    // We are done.
    return true;
  }

  /**
   * After this point, try to issue base stream element.
   */

  /**
   * Key point is to merge continuous stream elements within one cache line.
   * TODO: Really check if continuous. So far just consume until a different
   * TODO: cache line.
   */
  if (!stream->isNextElementAllcoated()) {
    return false;
  }

  // Get the first element.
  int numElements = 0;
  Addr vaddr = stream->peekVAddr();
  Addr paddr = stream->translateToPAddr(vaddr);
  Addr paddrLine = makeLineAddress(paddr);

  /**
   * Due to the waiting indirect element, a stream may not be migrated
   * immediately after the stream engine found the next element is not
   * handled here. In such case, we simply give up and return false.
   */
  if (!this->isPAddrHandledByMe(paddr)) {
    return false;
  }

  auto startIdx = stream->consumeNextElement();
  numElements = 1;

  // Try to get more elements.
  while (stream->isNextElementAllcoated()) {
    Addr nextVAddr = stream->peekVAddr();
    Addr nextPAddr = stream->translateToPAddr(nextVAddr);
    Addr nextPAddrLine = makeLineAddress(nextPAddr);
    if (nextPAddrLine == paddrLine && nextVAddr != 0) {
      // We can merge the request.
      stream->consumeNextElement();
      numElements++;
    } else {
      break;
    }
  }

  // Register the waiting indirect elements.
  if (!stream->indirectStreams.empty()) {
    for (auto idx = startIdx; idx < startIdx + numElements; ++idx) {
      stream->waitingIndirectElements.insert(idx);
    }
  }

  this->issueStreamRequestHere(stream, paddrLine, startIdx, numElements,
                               !(stream->indirectStreams.empty()));
  return true;
}

bool LLCStreamEngine::issueStreamIndirect(LLCDynamicStream *stream) {
  if (stream->readyIndirectElements.empty()) {
    // There is no ready indirect element to be issued.
    return false;
  }

  // Try to issue one with lowest element index.
  auto firstIndirectIter = stream->readyIndirectElements.begin();
  auto idx = firstIndirectIter->first;
  auto indirectStream = firstIndirectIter->second;

  Addr vaddr = indirectStream->getVAddr(idx);
  Addr paddr = indirectStream->translateToPAddr(vaddr);
  Addr paddrLine = makeLineAddress(paddr);

  /**
   * It's possible that the element is not handled here.
   */
  if (!this->isPAddrHandledByMe(paddr)) {
    // Send to other bank.
    this->issueStreamRequestThere(indirectStream, paddrLine, idx,
                                  1 /* numElements */, false /* fwdToSE */);
  } else {
    // Send to this bank;
    this->issueStreamRequestHere(indirectStream, paddrLine, idx,
                                 1 /* numElements */, false /* fwdToSE */);
  }

  // Don't forget to release the element.
  stream->readyIndirectElements.erase(firstIndirectIter);
  return true;
}

void LLCStreamEngine::issueStreamRequestHere(LLCDynamicStream *stream,
                                             Addr paddrLine, uint64_t startIdx,
                                             int numElements, bool fwdToSE) {
  LLC_ELEMENT_DPRINTF(stream->getStaticId(), startIdx, numElements,
                      "Issue [local] request.\n");

  auto selfMachineId = this->controller->getMachineID();
  auto streamCPUId = stream->getStaticStream()->getCPU()->cpuId();
  auto msg = std::make_shared<RequestMsg>(this->controller->clockEdge());
  msg->m_addr = paddrLine;
  msg->m_Type = CoherenceRequestType_GETU;
  msg->m_Requestor =
      MachineID(static_cast<MachineType>(selfMachineId.type - 1), streamCPUId);
  msg->m_Destination.add(selfMachineId);
  msg->m_MessageSize = MessageSizeType_Control;
  msg->m_streamMeta.m_valid = true;
  msg->m_streamMeta.m_stream =
      reinterpret_cast<uint64_t>(stream->getStaticStream());
  msg->m_streamMeta.m_streamId = stream->configData.dynamicId;
  msg->m_streamMeta.m_startIdx = startIdx;
  msg->m_streamMeta.m_numElements = numElements;
  // Forward the stream element data to us as we need it for indirect
  // streams.
  msg->m_streamMeta.m_fwdToSE = fwdToSE;

  Cycles latency(1); // Just use 1 cycle latency here.

  this->streamIssueMsgBuffer->enqueue(msg, this->controller->clockEdge(),
                                      this->controller->cyclesToTicks(latency));
}

void LLCStreamEngine::issueStreamRequestThere(LLCDynamicStream *stream,
                                              Addr paddrLine, uint64_t startIdx,
                                              int numElements, bool fwdToSE) {
  auto addrMachineId = this->mapPaddrToLLCBank(paddrLine);
  LLC_ELEMENT_DPRINTF(stream->getStaticId(), startIdx, numElements,
                      "Issue [remote] request to LLC%d.\n", addrMachineId.num);

  auto selfMachineId = this->controller->getMachineID();
  auto streamCPUId = stream->getStaticStream()->getCPU()->cpuId();
  auto msg = std::make_shared<RequestMsg>(this->controller->clockEdge());
  msg->m_addr = paddrLine;
  msg->m_Type = CoherenceRequestType_GETU;
  msg->m_Requestor =
      MachineID(static_cast<MachineType>(selfMachineId.type - 1), streamCPUId);
  msg->m_Destination.add(addrMachineId);
  msg->m_MessageSize = MessageSizeType_Control;
  msg->m_streamMeta.m_valid = true;
  msg->m_streamMeta.m_stream =
      reinterpret_cast<uint64_t>(stream->getStaticStream());
  msg->m_streamMeta.m_streamId = stream->configData.dynamicId;
  msg->m_streamMeta.m_startIdx = startIdx;
  msg->m_streamMeta.m_numElements = numElements;
  // Forward the stream element data to us as we need it for indirect
  // streams.
  msg->m_streamMeta.m_fwdToSE = fwdToSE;

  Cycles latency(1); // Just use 1 cycle latency here.

  this->streamIndirectIssueMsgBuffer->enqueue(
      msg, this->controller->clockEdge(),
      this->controller->cyclesToTicks(latency));
}

void LLCStreamEngine::migrateStreams() {
  auto streamIter = this->migratingStreams.begin();
  auto streamEnd = this->migratingStreams.end();
  int migrated = 0;
  while (streamIter != streamEnd && migrated < this->migrateWidth) {
    auto stream = *streamIter;
    // We do not migrate the stream if it has unprocessed indirect elements.
    if (stream->waitingIndirectElements.empty() &&
        stream->readyIndirectElements.empty()) {
      this->migrateStream(stream);
      streamIter = this->migratingStreams.erase(streamIter);
      migrated++;
    } else {
      ++streamIter;
    }
  }
}

void LLCStreamEngine::migrateStream(LLCDynamicStream *stream) {

  // Make sure it's okay to migrate the stream.
  assert(stream->waitingIndirectElements.empty() &&
         stream->readyIndirectElements.empty() &&
         "Can not migrate stream with unprocessed indirect request.");

  // Create the migrate request.
  Addr vaddr = stream->peekVAddr();
  Addr paddr = stream->translateToPAddr(vaddr);
  Addr paddrLine = makeLineAddress(paddr);
  auto selfMachineId = this->controller->getMachineID();
  auto addrMachineId =
      this->controller->mapAddressToLLC(paddrLine, selfMachineId.type);

  LLC_STREAM_DPRINTF(stream->getStaticId(), "Migrate to LLC%d.\n",
                     addrMachineId.num);

  auto msg =
      std::make_shared<StreamMigrateRequestMsg>(this->controller->clockEdge());
  msg->m_addr = paddrLine;
  msg->m_Type = CoherenceRequestType_GETS;
  msg->m_Requestor = selfMachineId;
  msg->m_Destination.add(addrMachineId);
  msg->m_MessageSize = MessageSizeType_Data;
  msg->m_Stream = stream;

  Cycles latency(1); // Just use 1 cycle latency here.

  this->streamMigrateMsgBuffer->enqueue(
      msg, this->controller->clockEdge(),
      this->controller->cyclesToTicks(latency));
}

MachineID LLCStreamEngine::mapPaddrToLLCBank(Addr paddr) const {
  auto selfMachineId = this->controller->getMachineID();
  auto addrMachineId =
      this->controller->mapAddressToLLC(paddr, selfMachineId.type);
  return addrMachineId;
}

bool LLCStreamEngine::isPAddrHandledByMe(Addr paddr) const {
  auto selfMachineId = this->controller->getMachineID();
  auto addrMachineId =
      this->controller->mapAddressToLLC(paddr, selfMachineId.type);
  return addrMachineId == selfMachineId;
}

void LLCStreamEngine::print(std::ostream &out) const {}

void LLCStreamEngine::receiveStreamIndirectRequest(const RequestMsg &req) {
  // Simply copy and inject the msg to L1 request in.
  assert(req.m_streamMeta.m_valid &&
         "Invalid stream meta for indirect request.");
  auto startIdx = req.m_streamMeta.m_startIdx;
  auto numElements = req.m_streamMeta.m_numElements;
  LLC_ELEMENT_DPRINTF(req.m_streamMeta.m_streamId.staticId, startIdx,
                      numElements, "Inject [remote] request.\n");

  auto msg = std::make_shared<RequestMsg>(req);
  Cycles latency(1); // Just use 1 cycle latency here.

  this->streamIssueMsgBuffer->enqueue(msg, this->controller->clockEdge(),
                                      this->controller->cyclesToTicks(latency));
}