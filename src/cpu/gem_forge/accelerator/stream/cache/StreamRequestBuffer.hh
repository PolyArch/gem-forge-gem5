#ifndef __GEM_FORGE_STREAM_REQUEST_BUFFER_HH__
#define __GEM_FORGE_STREAM_REQUEST_BUFFER_HH__

#include "DynamicStreamId.hh"
#include "mem/ruby/network/MessageBuffer.hh"
#include "mem/ruby/slicc_interface/AbstractStreamAwareController.hh"

// Generated by Ruby.
#include "mem/ruby/protocol/RequestMsg.hh"

#include <unordered_map>

/**
 * This class buffers issued stream requests. It will try to
 * limit the maximum number of inqueue requests per stream and
 * buffers overflowed requests. This is mainly used for fairness
 * and avoid unbalanced case.
 * NOTE: This is currently coupled with RequestMsg type.
 */

class StreamRequestBuffer {
public:
  using RequestPtr = std::shared_ptr<RequestMsg>;

  StreamRequestBuffer(AbstractStreamAwareController *_controller,
                      MessageBuffer *_outBuffer, Cycles _latency,
                      int _maxInqueueRequestsPerStream,
                      int _maxMulticastReqPerMsg, int _multicastBankGroupSize);
  void pushRequest(RequestPtr request);

  int curRemoteBank() const { return this->controller->getMachineID().num; }
  const char *curRemoteMachineType() const {
    return this->controller->getMachineTypeString();
  }

  int getTotalBufferedRequests() const { return this->totalBufferedRequests; }

private:
  AbstractStreamAwareController *controller;
  MessageBuffer *outBuffer;
  const Cycles latency;
  const int maxInqueueRequestsPerStream;
  /**
   * @maxMulticastRequests: The max number of messages chained in a multicast.
   *                        Set to 0 or 1 to disable this.
   * @multicastBankGroupSize: The bank group (size x size) to detect multicast,
   *                          0 means all.
   * So far only used to coalesce indirect requests.
   */
  const int maxMulticastReqPerMsg;
  const int multicastBankGroupSize;

  int totalBufferedRequests = 0;

  struct InqueueStreamState {
    int inqueueRequests = 0;
    std::list<RequestPtr> buffered;
  };
  using InqueueStreamMapT =
      std::unordered_map<DynamicStreamId, InqueueStreamState,
                         DynamicStreamIdHasher>;
  using InqueueStreamMapIter = InqueueStreamMapT::iterator;
  InqueueStreamMapT inqueueStreamMap;

  void dequeue(MsgPtr msg);

  /**
   * Get or initialize the inqueue stream map entry.
   */
  InqueueStreamMapIter getOrInitInqueueState(const RequestPtr &request);

  /**
   * Enqueue the request into the OutBuffer.
   */
  void enqueue(const RequestPtr &request, int &inqueueRequests);

  /**
   * Get the multicast group id. This basically just look at the single
   * destination of the message and is subjected to multicastBankGroupSize.
   *
   * MulticastGroupId may be invalid (-1) if the request has multiple
   * destination.
   */
  using MulticastGroupId = int;
  static constexpr MulticastGroupId InvalidMulticastGroupId = -1;
  MulticastGroupId getMulticastGroupId(const RequestPtr &request) const;

  /**
   * Records the inqueue requests by their multicast group id.
   */
  using MulticastGroupInqueueReqMapT =
      std::map<MulticastGroupId, std::set<RequestPtr>>;
  using MulticastGroupInqueueReqMapIter =
      MulticastGroupInqueueReqMapT::iterator;

  MulticastGroupInqueueReqMapT multicastGroupToInqueueReqMap;

  /**
   * Get or initialize the multicast group map.
   */
  MulticastGroupInqueueReqMapIter
  getOrInitMulticastGroupInqueueReq(MulticastGroupId groupId);

  /**
   * Check if the request should try multicast.
   * So far this multicast only applies to GETU/GETH/STREAM_STORE.
   */
  bool shouldTryMulticast(const RequestPtr &req) const;

  /**
   * Check if request can be multicast.
   * @return true if succeed.
   */
  bool tryMulticast(const RequestPtr &req);
};

#endif