#ifndef __CPU_TDG_ACCELERATOR_STREAM_MLC_DYNAMIC_STREAM_H__
#define __CPU_TDG_ACCELERATOR_STREAM_MLC_DYNAMIC_STREAM_H__

#include "SlicedDynamicStream.hh"

#include "cpu/gem_forge/accelerator/stream/stream.hh"

#include "mem/ruby/common/DataBlock.hh"

// Generated by slicc.
#include "mem/ruby/protocol/ResponseMsg.hh"

#include <list>

class AbstractStreamAwareController;
class MessageBuffer;

class MLCDynamicStream {
public:
  MLCDynamicStream(CacheStreamConfigureData *_configData,
                   AbstractStreamAwareController *_controller,
                   MessageBuffer *_responseMsgBuffer,
                   MessageBuffer *_requestToLLCMsgBuffer,
                   bool _mergeElements = true);

  virtual ~MLCDynamicStream() {}

  Stream *getStaticStream() const { return this->stream; }

  const DynamicStreamId &getDynamicStreamId() const {
    return this->dynamicStreamId;
  }

  virtual const DynamicStreamId &getRootDynamicStreamId() const {
    // By default this we are the root stream.
    return this->getDynamicStreamId();
  }

  /**
   * Helper function to check if a slice is valid within this stream context.
   * So far always valid, except the first element of indirect stream that is
   * behind by one iteration.
   */
  virtual bool isSliceValid(const DynamicStreamSliceId &sliceId) const {
    return true;
  }

  /**
   * Get where is the LLC stream is at the end of current allocated credits.
   */
  Addr getLLCStreamTailPAddr() const;

  virtual void receiveStreamData(const ResponseMsg &msg);
  void receiveStreamRequest(const DynamicStreamSliceId &sliceId);
  void receiveStreamRequestHit(const DynamicStreamSliceId &sliceId);

  /**
   * Before end the stream, we have make dummy response to the request
   * we have seen to make the ruby system happy.
   */
  void endStream();

protected:
  Stream *stream;
  DynamicStreamId dynamicStreamId;
  bool isPointerChase;

  SlicedDynamicStream slicedStream;

  AbstractStreamAwareController *controller;
  MessageBuffer *responseMsgBuffer;
  MessageBuffer *requestToLLCMsgBuffer;
  const uint64_t maxNumSlices;
  // Whether we can merge continuous slices if they are in the same cache
  // line.
  const bool mergeElements;
  /**
   * Represent an allocated stream slice at MLC.
   * Used as a meeting point for the request from core
   * and data from LLC stream engine.
   */
  struct MLCStreamSlice {
    DynamicStreamSliceId sliceId;
    DataBlock dataBlock;
    // Whether the core's request is already here.
    bool dataReady;
    enum CoreStatusE { NONE, WAIT, DONE };
    CoreStatusE coreStatus;

    MLCStreamSlice(const DynamicStreamSliceId &_sliceId)
        : sliceId(_sliceId), dataBlock(), dataReady(false),
          coreStatus(CoreStatusE::NONE) {}

    void setData(const DataBlock &dataBlock) {
      assert(!this->dataReady && "Data already ready.");
      this->dataBlock = dataBlock;
      this->dataReady = true;
    }

    static std::string convertCoreStatusToString(CoreStatusE status) {
      switch (status) {
      case CoreStatusE::NONE:
        return "NONE";
      case CoreStatusE::WAIT:
        return "WAIT";
      case CoreStatusE::DONE:
        return "DONE";
      default:
        return "ILLEGAL";
      }
    }
  };

  std::deque<MLCStreamSlice> slices;
  // Element index of allocated [head, tail).
  uint64_t headSliceIdx;
  uint64_t tailSliceIdx;
  // Where the LLC stream's tail index is.
  uint64_t llcTailSliceIdx;

  void advanceStream();
  void makeResponse(MLCStreamSlice &element);

  MLCStreamSlice &getSlice(uint64_t sliceIdx);
  const MLCStreamSlice &getSlice(uint64_t sliceIdx) const;

  /**
   * Helper function to translate the vaddr to paddr.
   */
  Addr translateVAddr(Addr vaddr) const;

  /**
   * Allocate stream element. It merges neighboring slices if they are from
   * the same cache line.
   */
  void allocateSlice();

  /**
   * Send credit to the LLC stream. Update the llcTailSliceIdx.
   */
  virtual void sendCreditToLLC();

  /**
   * A helper function to dump some basic status of the stream when panic.
   */
  void panicDump() const;
};

#endif